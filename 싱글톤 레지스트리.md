

![[Pasted image 20241212170315.png]]

POJO는 자바에서 서버 개발을 한다고 하면 특별한 클래스를 상속하고 특별한 조건을 맞춰야만 동작하는 코드를 만들어야 했음(EJB)

클래스를 상속해서 특정 객체를 타겟으로 동작하는거 쓰지말자 해서 나온게
Plain Old Java Object 이다.


![[Pasted image 20241212170515.png]]

Configuration
ComponentScan

이런것들을 가지고 구성정보를 다이나믹하게 생성하는 방법들이 있었다.




디자인 패턴을 공부하면 싱글톤 패턴을 공부해 보았을 것이다.

구조도 단순하고 목적도 분명한 패턴이다.

딱하나의 오브젝트만 존재해야 하는 경우가 있다.

이러한 오브젝트를 사용해야 하는 많은 오브젝트들이 존재하는데 

어떻게 필요한 오브젝트만 가져와서 사용할 것인가

get~() 이런걸 써서 가져오고 동작하게 하고 public static 메소드를 정통적으로 사용한다.

어떤 오브젝트와 일을 하겠다는 의존관계가 분명하지 않으면

마구잡이로 오브젝트를 이용하면 그런 구조가 일어날 수 있다.

이런 것들 좋지 않다.

static 메소드 이기 때문에 테스트하기 위한 환경을 만들기가 어렵다.

싱글톤 패턴의 장점 단점을 찾아보면 많이 나와있다

유명한 디자인 패턴 저자 중 한명이 말한게 싱글톤 패턴은 다시 책을 쓴다면 빼고 싶다.

싱글톤을 안쓰면 뭐 어떻게 할껀데 -> 스프링을 쓰면 된다

스프링을 쓰면 딱 하나만 생성해서 알아서 공유하고 관리하도록 해준다.

스프링은 대부분 서버 애플리케이션을 만들기 때문에 사용자 요청에 따라서 계속 새로운 오브젝트를 만들면 서버가 느려질 수 있다.

진짜 스프링이 한 객체 가지고 하는 지 알아보자

![[Pasted image 20241212171416.png]]


![[Pasted image 20241212171423.png]]

값이 같은 것을 볼 수 있다.




![[Pasted image 20241212171649.png]]

이건 어떻게 될까?

new 라는 것으로 인스턴스를 생성하면 자바에서는 새로운 인스턴스를 생성하게 된다고 배웠을 것이다

![[Pasted image 20241212171736.png]]

놀랍게도 같은 오브젝트가 나온다

왜?

스프링이 configuration이라는 구성정보를 사용되어질꺼라는 클래스는

메소드의 약간의 마법을 부린다.

특별한 다른 지시가 없다면 딱 하나만 생성하도록한다

앞에 Proxy라는 것을 붙여서 사용하도록 하는 방법인 것인데,,


스프링은 기본적으로 싱글톤 레지스트리로 동작하게 되어있다.



![[Pasted image 20241212172213.png]]

OrderService를 임시로 새로 작성해서 공통으로 사용하는 exRateProvier를 들고와보았다.

![[Pasted image 20241212172225.png]]

![[Pasted image 20241212172232.png]]

역시나 새로운 오브젝트를 주입해서 비교해도 사용되는 상위 객체는 딱 하나만 사용되고 있다는 것을 알 수 있다.




